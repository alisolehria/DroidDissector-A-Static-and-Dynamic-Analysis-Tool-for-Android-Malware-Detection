#!/usr/bin/env python
import sys
import subprocess
from subprocess import Popen, PIPE
import os
import shutil
from datetime import datetime
import logging

logging.basicConfig(filename="opcodes_modified.log", format='%(asctime)s %(message)s', level=logging.DEBUG)


def generate_opcodes(src_dir, opseq_dir, app_hash):

    opcode_dict = {}
    # Reading Davlik opcodes into a dictionary
    with open("tool/OPCODES.txt") as opcode_file:
        for line in opcode_file:
            (key, val) = line.split()
            opcode_dict[key] = val
    
    try:
        smali_directory = os.path.join(src_dir)
        if app_hash.endswith(".apk"):
            app_hash = app_hash[:-4]
        opseq_file_name = os.path.join(opseq_dir, app_hash + ".opseq")

        with open(opseq_file_name, "a", encoding="utf8", errors='ignore') as opseq_file:
            for root, dirs, filenames in os.walk(smali_directory):
                for filename in filenames:
                    full_path = os.path.join(root, filename)
                    opseq_file.write(generate_opcodes_content(full_path, opcode_dict))
                        
        return True
    except Exception as e:
        print(e)
        return False

def generate_opcodes_content(smali_file, opcode_dict):
    # Returns opcode sequence created from smali file 'smali_file'.
    opseq = ''

    with open(smali_file, mode="r", encoding="utf8", errors='ignore') as bigfile:
        reader = bigfile.read()
        for i, part in enumerate(reader.split(".method")):
            add_newline = False
            if i != 0:
                method_part = part.split(".end method")[0]
                method_body = method_part.strip().split('\n')
                for line in method_body:
                    if not line.strip().startswith('.') and not line.strip().startswith('#') and line.strip():
                        method_line = line.strip().split()
                        if method_line[0] in opcode_dict:
                            add_newline = True
                            opseq += opcode_dict[method_line[0]]
                if add_newline:
                    opseq += '\n'

    return opseq

def process_opcodes(app_file_dir, app_name, opseq_dir, decoded_dir):

    start_time = datetime.now().strftime('%H:%M:%S %d-%m-%Y')
    start_time_difference = datetime.now()
    print("===============Starting Script at: "+start_time+"===============")
    logging.info("===============Starting Script at: "+start_time+"===============")

    tmp_file_dir = 'tmp'

    if not os.path.exists("./opcodes"):
        os.makedirs("./opcodes")

    include_libs = False

    apps_to_process = [app_name]
    completed = []

    for root, dirs, files in os.walk(opseq_dir):
        for filename in files:
            completed.append(filename)

    num_local = 0
    analysis_complete = len(completed)

    for app_hash in apps_to_process:
        if app_hash+".opseq" not in completed:
            app_file_location = os.path.join(app_file_dir, app_hash)
            num_local += 1
            analysis_start = datetime.now()

            if (not os.path.exists(decoded_dir) or not os.listdir(decoded_dir)):
                continue

            result = generate_opcodes(decoded_dir, opseq_dir, app_hash)
            completed.append(app_hash)
            analysis_end = datetime.now()
            analysis_time = analysis_end - analysis_start
            print("This analysis took: " + str(analysis_time))
            logging.info("This analysis took: " + str(analysis_time))

    end_time = datetime.now().strftime('%H:%M:%S %d-%m-%Y')
    print("===============Script Ended at: "+end_time+"===============\n\n")
    logging.info("===============Script Ended at: "+end_time+"===============")
    end_time_difference = datetime.now()
    total_time = end_time_difference - start_time_difference
    print("Total Time Taken: " + str(total_time))
    logging.info("Total Time Taken: " + str(total_time))
